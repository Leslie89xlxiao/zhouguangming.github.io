---
layout: post
title: "Continuation in Ruby"
description: ""
category: 
tags: [ruby]
---

Continuation 的意思是延续, 在计算机领域是一种函数调用机制, 一种描述程序的控制状态的抽象，它用一个数据结构来表示一个执行到指定位置的计算过程, 这个数据结构可以由程序语言访问而不是隐藏在运行时环境中。Continuation 在生成之后可作为控制结构使用，在调用时会从它所表示的控制点处恢复执行。使用这种方式的编程风格叫做 Continuation Passing Style. 可能对于使用 Ruby 等面向对象的语言来说, 这个概念并不常听到, 但熟悉函数编程的人来说应该是非常熟悉的. 本文将简单介绍下 Ruby 中实现 Continuation.

<!--break-->

Ruby 中的 Continuation 是通过 callcc 函数生成 Continuation 对象实现的. 

> Continuation objects are generated by Kernel#callcc, after having +require+d continuation. They hold a return address and execution context, allowing a nonlocal return to the end of the callcc block from anywhere within a program. Continuations are somewhat analogous to a structured version of C's setjmp/longjmp (although they contain more state, so you might consider them closer to threads).

callcc 是 call-with-current-continuation 的缩写. 下面是一个简单的例子:

{% highlight ruby %}
# continuation_example.rb

require 'continuation'

def foo
  10.times do |i|
    puts "the number: #{i}"
    $cc = callcc { |cc| cc } if i == 5
  end
end

foo

$cc.call if $cc

# output

the number: 0
the number: 1
the number: 2
the number: 3
the number: 4
the number: 5
the number: 6
the number: 7
the number: 8
the number: 9
the number: 6
the number: 7
the number: 8
the number: 9
{% endhighlight %}

foo 方法遍历 10 以内的数字, 当 i == 5 时通过 callcc 方法生成 Continuation 对象, 并将这个对象复制给全局变量 $cc, continuation 有一个 call 方法, 该方法用于调用 continuation. Continuation 对象在创建时保存当前运行状态的上下文，在该对象调用 call 方法时, 便可回到创建时的样子, 并且继续执行下去, 这也就很好的解释了上例的输出结果. 乍一看就很像 goto 的样子, 但是比它高级很多, 好像时光机一样.

下面是几个关于 continuation 好玩的东西:

1. [http://liber.sourceforge.net/coroutines.rb](http://liber.sourceforge.net/coroutines.rb)
2. [https://github.com/chikamichi/amb](https://github.com/chikamichi/amb)
3. [https://github.com/mneumann/wee](https://github.com/mneumann/wee)
